Great. I’ll prepare a complete repository layout and implementation plan for a system-level Linux MIDI synthesizer daemon using FluidSynth for GM playback. It will integrate with whichever audio backend is present (JACK, PipeWire, PulseAudio), support both global and per-user config, and auto-start via systemd.

I’ll return shortly with a full filesystem structure and a modular development roadmap covering device creation, daemon architecture, and packaging strategy.


# System-level MIDI Synthesizer Daemon for Linux

This design outlines a **system-level MIDI synthesizer daemon for Linux** – an equivalent to the Microsoft GS Wavetable SW Synth on Windows. The daemon uses **FluidSynth** as the core engine to provide General MIDI playback, exposing itself as an ALSA sequencer device so any MIDI-capable application can use it transparently. It will intelligently integrate with the host audio system (JACK, PipeWire, PulseAudio) without user intervention, support flexible configuration (both system-wide and per-user), and run as a background service (with systemd auto-start by default). The following sections present the planned repository layout and a step-by-step implementation plan.

## Filesystem Layout

Each source file  represents a logical module of the daemon: `main.c` initializes the service, `synth.c` wraps FluidSynth functionality, `midi_alsa.c` handles ALSA sequencer I/O, etc. The configuration and systemd directories provide integration with the OS environment, and the tests directory ensures each component works correctly.)*

## Implementation Plan

The development will proceed in sequential steps, addressing core functionality first and then integration and configuration. Each step lists the relevant technologies/libraries, design considerations, and testing/packaging strategies:

1. **Project Setup and Dependencies**

   * **Technologies & Libraries:** Initialize a C/C++ project (e.g. using C99 or C++17) with a build system like CMake or Meson. Add **ALSA sequencer** library (libasound) for MIDI input, **FluidSynth** (libfluidsynth) for synthesis, and a configuration parsing library such as **libconfig** or **json-c** for reading config files. Include **systemd** development files if using `sd_notify` or other systemd-specific APIs. Set up a GitHub Actions CI workflow to build the project on Linux and run tests on each commit.

   * **Design Considerations:** Organize code into modules (as reflected in the directory layout) for clarity and maintainability. Determine the daemon name (`midisynthd`) and ALSA client name. Plan for a modular design: the main program will initialize config, audio, MIDI, and synth modules in order. Consider the threading model early: FluidSynth spawns its own audio thread (and possibly MIDI thread) for real-time processing, so the main thread can be used for control and signal handling. Ensure the project links with the necessary libraries and consider using static analysis and coding standards (e.g. clang-tidy, cppcheck) as part of CI.

   * **Testing & Packaging:** Write initial unit tests (possibly using a lightweight framework like **CMocka** or **GoogleTest**) for any utility functions (e.g., config parser test with a sample config string). Verify in CI that the project builds in different environments (for example, with JACK present vs not present, PulseAudio vs PipeWire available, etc., to ensure the code handles optional dependencies). No actual packaging is done in this step, but lay the groundwork for packaging: e.g., ensure the build system can produce a library or binary and consider how it will be installed (prefix, etc.). This step results in a skeletal daemon that does nothing yet, but confirms the development environment is set up correctly.

2. **FluidSynth Engine Integration (Audio Output Setup)**

   * **Technologies & Libraries:** Utilize the FluidSynth API to create the synthesizer instance. Call `new_fluid_settings()` to configure synthesis parameters and `new_fluid_synth()` to instantiate the synth. Use **FluidSynth** to load a General MIDI SoundFont (e.g. **FluidR3\_GM.sf2** or another free GM sound set) so that a full range of GM instruments is available. Create an audio driver via FluidSynth (using `new_fluid_audio_driver()`) with an appropriate audio backend. This step will involve integration with **JACK**, **PipeWire**, or **PulseAudio** as the output driver, using FluidSynth's support for those audio systems.

   * **Design Considerations:** Ensure the synthesizer is configured for General MIDI. This means 16 MIDI channels (with channel 10 as percussion/drums by GM standard), and the loaded soundfont should contain the standard 128-instrument set. Set a default sample rate (e.g. 48000 Hz as recommended for modern systems) and a reasonable polyphony (e.g. 256 voices) balancing performance and quality. Implement **audio subsystem detection**: on startup, the daemon should detect the active sound system and choose the best FluidSynth audio driver without user intervention. For example:

     * If a JACK server is running, use the JACK driver (low-latency pro-audio scenario).
     * Otherwise, if PipeWire is available (as is common in modern Linux desktops), use the PipeWire driver (FluidSynth 2.x supports `audio.driver = pipewire`).
     * If neither is appropriate, fall back to PulseAudio (which will also route through PipeWire if that’s the system’s sound server). This avoids using raw ALSA output by default, since grabbing the ALSA device exclusively could conflict with the user's sound server. Only if no sound server is detected (e.g. on a headless system) would it use ALSA output directly.
       These decisions can be coded by trying drivers in priority order or by runtime detection (e.g., attempt a JACK client connection to see if JACK is up). Also consider buffer settings: use safe defaults (FluidSynth defaults, or adjust `audio.period-size`/`audio.periods` if needed) and possibly allow tweaking via config if crackling occurs (the Arch Wiki notes increasing `--audio-bufsize` to avoid PipeWire underruns).

   * **Testing & Packaging:** After implementing this step, the daemon should be able to synthesize audio from manually fed notes. Testing will involve creating a **dummy MIDI input** (since MIDI input integration comes in the next step) or using FluidSynth’s API to send a test note: for example, call `fluid_synth_noteon(synth, channel, note, velocity)` in code and verify that audio is produced. Automated testing of actual sound output is tricky, but we can use FluidSynth's file rendering capabilities in tests (e.g., use the Wave file driver in a test mode to render a few notes to a buffer or file, then check that the output buffer is not silent). We will also verify that the chosen audio driver matches the environment (e.g., in a test environment with JACK headers available but JACK server not running, ensure the daemon falls back to PulseAudio). Packaging considerations: at this stage, ensure the build system lists FluidSynth and ALSA as required libraries. We will also decide how to bundle or depend on a GM soundfont – for example, the **Debian/Ubuntu package** may declare a dependency or recommendation on `fluid-soundfont-gm` (so the user has a GM sound set installed), or the project may include a small default SoundFont if licensing permits. This step confirms that audio output works with the core engine on various backends.

3. **ALSA Sequencer MIDI Input Integration**

   * **Technologies & Libraries:** Use the ALSA sequencer interface (via libasound) or FluidSynth’s built-in MIDI driver to create a MIDI input port that applications can send MIDI events to. On Linux, FluidSynth can act as a sequencer client providing a MIDI input port. We will configure FluidSynth with `midi.driver = alsa_seq` (the default on Linux) and use `new_fluid_midi_driver(settings, handler, data)` to create the MIDI port. By providing FluidSynth's own synth as the event handler (`fluid_synth_handle_midi_event`), incoming MIDI messages will be processed by the synth automatically. In essence, FluidSynth will handle Note On/Off, Program Change, Control Change, SysEx (like GM reset) and all MIDI events internally when wired this way. Alternatively, we could manually interface with ALSA: open a sequencer client (`snd_seq_open()`), create a port, and in a thread loop (`snd_seq_event_input()`) translate ALSA events to FluidSynth API calls (e.g. on SND\_SEQ\_EVENT\_NOTEON call `fluid_synth_noteon`). However, leveraging FluidSynth's existing ALSA sequencer driver is cleaner and ensures we don’t miss any MIDI message types.

   * **Design Considerations:** **ALSA Sequencer Client Setup:** Register the daemon as a persistent MIDI synth device. We’ll set a recognizable client name (e.g. `"MidiSynth Daemon"` or `"FluidSynth Daemon"`) instead of the default “FLUID Synth (pid)”, by using FluidSynth’s `midi.alsa_seq.id` setting to a fixed string. The sequencer port will be opened in subscription mode so any MIDI client can connect. To mimic the Windows GS Synth behavior of being the default MIDI device, we consider **auto-connection** of hardware MIDI inputs: FluidSynth’s `midi.autoconnect` can be enabled so that any ALSA MIDI controller (keyboard, etc.) is automatically connected to our synth port when available. This is useful for users who plug in a keyboard and expect sound without manual routing. (We will make this configurable in case a user prefers to manage connections manually.) The daemon should also handle multiple concurrent MIDI clients gracefully – ALSA sequencer will timestamp and queue events, and FluidSynth can handle simultaneous events on different channels/ports. We must ensure real-time performance: the MIDI input handling thread (spawned by FluidSynth or by us) should run with a high scheduler priority. FluidSynth by default sets `midi.realtime-prio = 50` for ALSA sequencer input, which will attempt to use SCHED\_FIFO if permissions allow. We will document that users may need to be in the `audio` group or configure `/etc/security/limits.conf` if ultra-low latency MIDI is required, though in most cases it should run fine under normal scheduling.

   * **Testing & Packaging:** At this stage, end-to-end MIDI-to-audio functionality can be tested. Write an integration test that uses ALSA sequencer in loopback: e.g., open a client in the test that sends a Note On event to our daemon’s port (using `snd_seq_event_output_direct` or an external utility). Verify that the note is synthesized (for testing, perhaps we can monitor FluidSynth’s internal state or use a short dummy soundfont that produces a known output). Another test is to simulate a MIDI file playback: use ALSA sequencer to feed a sequence of events (or use FluidSynth’s MIDI file player API with our synth) and ensure no crashes or stuck notes occur. We will also test the auto-connect feature by emulating a new client connection and verifying the daemon’s port gets the subscription (this can be done via ALSA calls or checking FluidSynth logs). For packaging, this step doesn’t introduce new files, but it's a good point to ensure that our binary gets the necessary **capabilities/permissions** if needed (for example, if we wanted to allow real-time priority without root, we might consider using `setcap` to grant `CAP_SYS_NICE` to the binary in packaging, though this might not be strictly necessary). We’ll also ensure the ALSA sequencer dependency (usually provided by `libasound2`) is properly declared in package metadata.

4. **Configuration Management (Global and Per-User Settings)**

   * **Technologies & Libraries:** Implement a configuration system using the chosen config library (e.g. libconfig for a `.conf` file with INI/CFG style, or json-c for JSON). Provide a default config file installed in `/etc` (system-wide defaults) and allow an override config in the user’s home (e.g. `~/.config/midisynthd.conf`). The daemon will parse both: first load global config, then load user config (if present) to override specific settings. Key settings include **SoundFont path(s)**, **MIDI/Audio driver preferences**, and synth parameters like **gain** (master volume), **polyphony** (max voices), **channels**, **default sample rate**, **midi.autoconnect toggle**, etc. We might use a simple structure like INI sections or key-value pairs. For example, a config might have:

     ```
     soundfont = "/usr/share/soundfonts/FluidR3_GM_GS.sf2"  
     gain = 0.5  
     polyphony = 256  
     audio_driver = "pipewire"    # default audio driver preference  
     auto_connect = true         # auto-connect MIDI inputs  
     ```

     Using libconfig, we can allow comments and a structure; with JSON we’d have similar fields (but no comments). The choice of format leans on maintainability: **libconfig** provides a human-friendly syntax and allows comments in config files, which is beneficial for sysadmins (this aligns with how FluidSynth on Arch uses a config in `/etc/conf.d/fluidsynth` with comments).
   * **Design Considerations:** **Config Precedence:** The system-wide config `/etc/midisynthd.conf` provides defaults (e.g., default soundfont, standard settings chosen by distro or admin). The per-user config `~/.config/midisynthd.conf` can override these for a specific user’s session (e.g., a user could specify a custom soundfont in their home directory, different volume, etc.). The daemon, when run as a user service, will read both and merge settings (with user settings taking precedence). When run as a system service (if that mode is used), only the global config is applied (since it runs without a particular user context). We must handle errors gracefully: if config files are missing or a key is not set, use compiled-in defaults. Provide sensible defaults so that even with no config file, the daemon will still function (e.g., try to locate a common GM soundfont in standard locations like `/usr/share/soundfonts/default.sf2` or similar). **Hot Reload vs Restart:** It’s generally sufficient to read config at startup; if the user changes settings, they can restart the service. We may document a SIGHUP handler to reload config for advanced use, but that is optional. **SoundFont selection:** Support multiple soundfonts if needed (FluidSynth can load multiple soundfonts and stack them). However, for simplicity and memory, we’ll likely use one default GM soundfont at a time. We might implement a small utility function to verify the soundfont file exists and log an error if not (to avoid the common pitfall of “no sound because soundfont path is wrong”). **Logging and Debugging:** Include config options for log level (info/debug) so that troubleshooting is easier. The daemon can log its chosen audio driver, loaded soundfont, etc., to syslog or stderr.

   * **Testing & Packaging:** Develop unit tests for the config parser: feed it sample config strings/files and ensure it correctly populates the internal settings structure. Test merging of configs by simulating a global and user config with different values. Also test fallback to defaults when keys are missing. For example, a test can write a temporary config file with only one setting changed and verify all other settings remain at default values. **Citations of known behavior:** (In documentation we will note that our config approach is similar to FluidSynth’s own config in Arch: `/etc/conf.d/fluidsynth` for defaults and user overrides in `~/.config/fluidsynth`.) In packaging, ensure the default config is installed to `/etc/midisynthd.conf` (or `/etc/midisynthd/midisynthd.conf` if we prefer a subdir). Mark this file as a config file in packaging so that user modifications are preserved on upgrade. We will also install an example config or comment-rich default to guide users. The package post-install script might check if a default soundfont is present and, if not, suggest installation of a recommended package (though this can also be handled via package dependencies or README instructions). At this point, the daemon is configurable and flexible for different environments.

5. **Daemonization and Service Auto-start Integration**

   * **Technologies & Libraries:** Leverage **systemd** to manage the daemon’s lifecycle. We will create two unit files: one for a system service and one for a user service. The **systemd user service** (installed in `/usr/lib/systemd/user/midisynthd.service`, referenced in our layout as `midisynthd-user.service`) is the primary way the daemon will run, since it’s typically run under the logged-in user (to access that user’s PulseAudio/PipeWire session). The system-wide service (`/usr/lib/systemd/system/midisynthd.service`) can be provided for special cases (e.g. headless systems or where audio is system-scoped), but by default it will remain disabled because PulseAudio/PipeWire do not allow root clients. We will utilize systemd features such as `WantedBy=default.target` in the user unit so that users can enable it to start automatically on login. If possible, use `Type=simple` (the daemon does not fork, it will run in the foreground under systemd) or `Type=notify` with `sd_notify()` if we want to signal readiness after initialization (this could help in scenarios where MIDI clients are started at login and we want to ensure our port is up before they try to use it, but this might be over-engineering; Type=simple is usually fine).

   * **Design Considerations:** **Daemon Behavior:** Implement the ability for the program to run in either foreground or background mode. When launched by systemd (which provides supervision), it will run in the foreground (no double-forking) so logs go to journal. We might include an option (e.g. `-d` or `--daemonize`) to fork into background for users who do not use systemd and want to run it manually. Ensure proper signal handling: catch SIGTERM (from systemd stop or manual kill) to gracefully shut down – i.e., close the ALSA sequencer port, delete FluidSynth objects (which will terminate audio and MIDI threads), and free resources. For cleanliness, also handle SIGINT for manual stops, and maybe SIGHUP if we implement config reload. **Automatic Startup:** Document that for most desktop users, enabling the user service (`systemctl --user enable midisynthd.service`) will cause the synthesizer to auto-start at login, providing a MIDI synth device without any manual steps. In the service unit, use an `After=` dependency on sound server services if available (e.g., `After=pipewire.service pulseaudio.service` in the user unit) so that our daemon starts after the audio system is up. Also, `WantedBy=default.target` (for user) makes it start on graphical login by default when enabled. For the system service, we will not enable it by default (to avoid conflicts), but if used, it might be `WantedBy=multi-user.target` with an option in `/etc/default/midisynthd` to choose an ALSA backend, etc. **Permissions:** Running as a user means no special privileges needed in most cases. If the system service is used, we must decide under which user it runs – it could run as the `pulse` user or a dedicated `midisynth` user in audio group, to be able to use ALSA devices. However, given the PulseAudio limitation for root, the recommended mode remains user service.
   * **Testing & Packaging:** Test the daemon in real usage scenarios. On a test machine or VM, install the service and config, then:

     * Test **user service**: `systemctl --user start midisynthd.service` – verify the process starts, creates the ALSA port, and connects to audio. Check `aconnect -l` or `pmidi -l` to see that the port is listed (e.g., `FLUID Synth ... Synth input port` or custom name). Play a MIDI file using a tool like `aplaymidi -p <client>:<port>` and confirm audio is heard. Also verify that if a USB MIDI keyboard is attached, it auto-connects and plays (if autoconnect is enabled).
     * Test **auto-start**: enable the user service and log out/in to ensure it launches on login.
     * Test **system service** (if provided): simulate a headless environment where PulseAudio isn’t running – start the system service (perhaps configured with `-a alsa` in this mode) and check that it grabs the hardware ALSA device and produces sound (this requires exclusive audio or dmix). Also ensure that when PulseAudio *is* running, the system service either fails gracefully with a clear error or is not used, to prevent silent audio conflicts.
       Logging can be checked via `journalctl --user -u midisynthd` to confirm our logs on startup show the chosen audio driver and soundfont, etc. In packaging, ensure the systemd service files are installed in the correct locations and **enabled appropriately**. For example, the Debian packaging could use `dh_installinit`/`dh_installsystemd` for the system service (but set it to **disabled** by default), and install the user unit to `/usr/lib/systemd/user`. The post-install script might print a message about how to enable the user service (since package managers typically don’t auto-enable user units). We will also include any necessary integration for desktop environments – though since this is a headless background service, it doesn't need a GUI icon or .desktop file. However, we should verify that the MIDI port is indeed the default for apps: e.g., some older apps pick the first MIDI port (which might be `Midi Through`). If the presence of the dummy `Midi Through` port causes issues (some apps sending MIDI there by default), we might advise users to remove or blacklist the `snd_seq_dummy` module so that our synth is the first and only MIDI output. Such guidance can be added to documentation for a truly seamless experience akin to Windows. Finally, the packaging step will produce distributable packages (e.g. a `.deb` and `.rpm`) including the binary, default config, service files, and possibly a default soundfont or a suggestion to install one. Continuous integration can be configured to build these packages and perhaps run a basic integration test (for example, in a Docker container with systemd or using a headless Xvfb environment to simulate a login, though that can be complex). At minimum, CI will build release artifacts and run the unit tests on every push.

6. **Quality Assurance and Future Enhancements**
   *(This is more of a wrap-up step to ensure completeness.)*

   * **Technologies & Libraries:** For QA, we might incorporate tools like **Valgrind** or sanitizers to ensure stability (no memory leaks when the daemon runs long-term, no crashes on edge cases). If not already, use a logging library or incorporate systemd’s logging macros to improve maintainability of log output.

   * **Design Considerations:** Review thread safety and performance. Ensure that under heavy MIDI load (e.g. playing a complex MIDI file with many simultaneous notes), the audio remains glitch-free – this may involve tuning thread priorities or buffer sizes (which can be exposed via config as mentioned). Also consider how updates to FluidSynth or audio systems might affect our daemon – e.g., if PipeWire becomes the standard, ensure our default config uses it (which we already plan to do). Think about security: although this daemon primarily handles MIDI and audio, if running as a system service it’s processing input from potentially any user’s MIDI client. We should ensure it drops root privileges if started as root (run as an unprivileged user) and doesn’t expose any network service. MIDI processing is low-risk, but we will harden the daemon by validating inputs (MIDI messages are fairly structured; still, avoid buffer overflows on SysEx, etc.).

   * **Testing & Packaging:** Perform stress tests: e.g., feed a large MIDI file or a stream of random MIDI events to the sequencer port for a sustained period and monitor CPU and memory usage. The daemon should handle this gracefully without significant memory growth (FluidSynth voices should be recycled properly). Include an integration test for saving and loading state if applicable (not explicitly required, but e.g., test if the daemon can be stopped and started with consistent behavior, and possibly in the future remember last soundfont or settings if hot-swapping soundfonts becomes a feature). For packaging, this final step is about polishing: ensure our Debian package lintian checks are clean, RPM spec is compliant, and that all installed files have correct permissions (e.g., config file world-readable, service files 644, binary has correct ownership and capabilities if any). We’ll also double-check **desktop integration**: when the daemon is running, it should appear as an **audio stream** in PulseAudio/PipeWire (e.g., listed as `midisynthd` or `FluidSynth` in volume controls) and as an ALSA client in MIDI connection managers. This means users can control its volume through their standard audio mixer, and MIDI applications see it as a normal MIDI output port (for example, `128:0 MidiSynth Daemon` when listing MIDI ports). Our documentation will highlight this, instructing that any MIDI player or sequencer can send to this port to utilize the synth. With everything tested and packaged, we will be ready to release the daemon. Future enhancements (beyond the scope of initial implementation) could include a small GUI or CLI to control settings at runtime, support for multiple MIDI ports or per-user multiple instances, and updating the daemon to adopt new standards (for instance, integration with upcoming PipeWire MIDI APIs if they emerge). The delivered system, however, will already meet the core goal: providing a seamless, auto-starting General MIDI synthesizer service on Linux, comparable to the classic built-in synth on Windows, and configurable to the user’s needs.
